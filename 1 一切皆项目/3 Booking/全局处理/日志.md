# 日志

日志主要通过logback.xml文件进行配置；

配置中主要包括

* qta：booking中所有未指定的日志均由此打印
* request：主要是http请求的接口返回。它通过配置派出了一些http路径（lua、动态、静态接口）；
* product：记录报价数据

如何决定使用哪个日志记录器？

默认使用qta，或者使用日志工厂通过日志收集器名称来进行获取：

```java
LoggerFactory.getLogger(requestLogger) //使用requestLogger来进行打印
```

### 过滤器

过滤器的继承、实现关系为：

​`LogFilter`​->`OncePerRequestFilter`​->`GenericFilterBean`​->`Filter...`​

其中

* ​`Filter`​是顶级过滤器接口不必多言；
* ​`GenericFilterBean`​这个接口主要是用于加载web.xml中的配置信息；
* ​`OncePerRequestFilter`​这个接口顾名思义，每次请求只调用一次**该过滤器。**   
  实现原理：  
  ​`LogFilter`​会实现`OncePerRequestFilter`​的`doFilterInternal`​（注意不是doFilter接口）；  
  如果`doFilterInternal`​被调用，就会向request请求中写入一个相关的key；下次再次执行过滤器链的时候会查看该key是否存在，如果存在则说明已经调用过了，就不会再调用`doFilterInternal`​这个方法了。  
  在执行完之后，会调用`request.removeAttribute(alreadyFilteredAttributeName);`​来清楚额外的参数；  
  显然，如果想只被过滤一次，重写`doFilterInternal`​方法即可。
* LogFilter是怎么被调用，又是如何决定调用时机的？  
  要解决这个内容，估计得学习一下xml的配置信息是如何作用的。

### 记录

* 如果非异步，则日志收集进行异步化；
* 移除resp中的lua脚本。
* 为何调用一个没实现的接口？`diff -> diff.runDiff(responseString)`
* 循环日志收集器  
  如果当前路径与日志收集器路径相匹配`collector.match(uri)`​，则调用该收集器进行收集动作，收集日志需要一些参数：请求头、http的req和resp、uri等内容；

### 收集器

1.**进订、下单异常收集器**​`**BookingExceptionLogCollector**`​

* 该收集器只针对进订和下单

* 排除beta、软路由、灰度、非生产环境等；
* 准备一些必要参数：c参、b参、上下文；
* 发送猜你喜欢用户行为特征数据的mq；
* 发送变价消息（排查演练）
* 发送”价格刷新消息“，这个价格刷新是为啥要触发？
* 填充进订阶段的数据

  * d页的trace、fastprice的trace等
  * 使用refreshExt进订的trace替换preTreaceID。没看懂为啥。
  * 改单会有bizType = 2；
  * 演练相关表示
  * 塞入变价数据
  * 强制刷新报价类型，如果有；
  * 还有一大堆入离日期、产品信息放进去。
* 填充下单阶段的数据

  * 产品必要信息
  * 由presubmit接口转换到booking接口
  * 记录一些下单特有参数，例如一些奇怪的trace
  * 如果是改单则有改单表示bizType = 2；
* 发送异常的消息，供misc等系统使用。

**2.Request收集器**

* 该收集器的范围比较大，”黑名单“之外的所有接口都收集。不收集的由动态、静态请求、lua接口等。
* 敏感信息打码。敏感信息包括身份证、手机号、邮箱；这个收集器来自于xml的配置；
* 将入参、返回、uri、时间等信息以字符串的形式打印出来。
* 演练、真实请求分开记录。演练记录到csp。演练的trace以cm开头。

**3.预售异常收集器**

* 记录的路径：预售的进订+下单，同时有开关。
* 预售的biztype = 3；
* 填充必要的字段，b参、c参、产品信息、下单特有参数；
* 发送预售失败消息。

‍

‍
