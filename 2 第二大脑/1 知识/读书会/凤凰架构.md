### 原子性与持久性

持久性意味着一旦事务生效，不会因为任何原因导致其修改的内容被撤销或者丢失。

崩溃是无法避免的，所以数据库重启之后一定要知道崩溃前一次发生过一次不完整的操作。根据已提交/未提交来判定是要回滚还是写入磁盘。

为了完成这个目标，不过直接将值修改。需要将修改过程都记录下来：在磁盘的什么位置，从什么值改成了什么值等等，以日志的形式记录到磁盘。只有日志记录全部安全落盘，数据库看到代表事务成功提交的“提交日志”之后才会根据日志信息对数据库进行真正的修改。修改完成之后，在日志中再追加一条“结束记录”表示事务已经持久化完成。

这种提交方式被称之为“提交日志”（commit Logging）

过程：所有操作先做提交日志->提交日志完成之后（commit record）进行数据修改落盘->落盘完成追完一条结束记录（end record）。如果失败，则回滚/写入。

有一些问题：

Comit Logging在事务提交之前不允许修改数据。如果要修改的数据很多，则性能极为不利。

ARIES提出一种解决方案：提前写入。提前写入根据事务的提交节点，将如何写入变动数据划分为了Force和Steal两种情况：

- FORCE：事务提交之后，要求变动数据必须同时完成写入则称之为FORCE，不强制则成为NO-FORCE。现实中绝大部分都是NO-FORCE，因为只要有日志，随时可以持久化。
- STEAL：事务提交前允许修改数据，则称为STEAL，不允许则称为NO-STEAL。

Write-Ahead Logging允许NO-FORCE也允许STEAL。
## RPC
RPC的三个基本问题

- 如何表示数据
    
    - 序列化与反序列化
- 如何传递数据
    
- 如何表示方法
    

### REST风格

- rest和rpc只是有一些相似，rest是一个“风格”，而不是一个协议。
    
- 什么是rest风格？
    
    - respresentational state transfer，表征状态转移。
        
        - 资源：将所有的内容都视作一种“资源”。假设你正在阅读一本书，这本书就是一种资源。
        - 表征：当你阅读这本书，浏览器向服务器发出“我需要这个资源”，服务器向浏览器返回的HTML就是这个资源的“表征”。表征是信息与用户的交互形式。
        - 状态：如果读完这本书，想读下一本。其中的“下一本”依赖于当前是哪一本，依赖于当前的状态。是否有状态这是对于服务器而言，有状态则是服务器记录这个状态，无状态则是有人替服务器记录了这个状态。
        - 转移：服务端通过某种形式，将“当前阅读的文章”转换成“下一篇文章”，这就是表征状态转移。
    - 对此的广义理解是软件的架构风格，狭义的理解是“远程服务设计风格”，前者是后者的一个很大超集。
        
    - restful的系统几个原则：
        
        - 客户端与服务端分离。
            
        - 无状态。rest系统服务器本身不去维护状态，所有需要记录的上下文语境信息全部传给客户端，服务端只依赖客户端传递过来的绘画信息去处理。
            
            > 安全？传输成本和效率？业务上能实现吗？
            
        - 可缓存。无状态可能需要C/S之间多次交互，所以希望能有中间容器将一些信息缓存起来，以提升效率。
            
        - 分层系统。
            
        - 统一接口【核心】：rest希望开发者面向资源变成，希望抽象出系统有哪些资源，而不是抽象出有哪些行为。
            
            > 对于一个登录和注销功能。
            > 
            > 面向行为，则应该对应login和logout两个独立的服务。
            > 
            > 面向资源，则登录时put session，删除是delete session。只需要设计一种资源。
            > 
            > 面向资源更加抽象，但更难理解。
            
    - rest的一些好处：
        
        - 降低接口学习成本。所以对于资源的操作都被映射到HTTP方法上。
        - 资源天生具有集合与层次结构。
        - rest严格与Http绑死。好处：成熟，坏处：一旦http不支持，那么就很难解决。
    - rest的争议：
        
        - 面向资源更适合crud。面向过程和对象才能真正处理复杂逻辑。
        - 与http绑定，不适合要求高性能的场景。
        - rest 没有传输可靠性的支持。（没理解）
        - rest缺乏对于资源进行“部分”和“批量”处理的能力。每次拿到的都是整个资源对象，如何只拿到资源的一部分，或者一次操作N多资源呢？