> 本文将从以下几个方面来行文：
> 
> - 动态代理的概念；
> - cglib动态代理和jdk动态代理的特点；
> - cglib和jdk动态代理的性能测试；
> - cglib源码解析。
> 
> 看完之后能够加深对于动态代理底层的理解。但本文不会对非常底层的源码进行解析，例如ASM框架、cglib代理类如何生成。

### 概念

动态：可以在程序运行的过程中进行；

代理：代理是一种手段，用于在已有的业务基础上进行行为增强。

框架里面大量使用，例如AOP等。

### 特点对比

- 实现原理  
    jdk基于反射机制，要求被代理的对象必须实现对应的接口。  
    cglib它是基于asm这种字节码创建框架来进行，它不需要实现接口，它是基于继承来实现的，所以必须得保证你的类是非fnial（可继承的）
    
- 性能表现
    
    jdk似乎更快一点。但并没有非常大的性能差距，并且两者都有缓存机制。  
    可见下方不是特别普适的性能测试。
    
- 适用场景
    
    jdk更适合强调接口定义的类上面。它不需要引入外部的依赖，使用上更加简洁。
    
    cglib的普适性更广一些，无法实现对于final类的代理（这种应该很少吧），对于没有接口且不是很想实现接口的场景下更合适。
    

### 性能测试

1、测试代码一

业务逻辑do noting、增强逻辑do nothing

```java
public class Test {

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        int cnt = 1;
        for (int i = 0; i < cnt; i++) {
            javaTest();
        }
        long mid = System.currentTimeMillis();
        for (int j = 0; j < cnt; j++) {
            cglibTest();
        }
        long end = System.currentTimeMillis();
        System.out.println("java proxy = " + (mid - start));
        System.out.println("cglib proxy = " + (end - mid));

    }

    public static void javaTest() {
        final User user  = new User();
        long start = System.currentTimeMillis();
        Say say = (Say)Proxy.newProxyInstance(User.class.getClassLoader(), new Class[]{Say.class}, new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                return method.invoke(user, args);
            }
        });
        long end = System.currentTimeMillis();
    }

    public static void cglibTest() {
        final User user = new User();
        long start = System.currentTimeMillis();

        // 设置enhancer对象的父类
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(User.class);
        // 设置enhancer的回调对象
        enhancer.setCallback(new MethodInterceptor() {
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                // 代理逻辑
                methodProxy.invoke(user, objects);
                return null;
            }
        });
        // 创建代理对象
        User proxyUser = (User)enhancer.create();
        long end = System.currentTimeMillis();
    }
}
```

2、结果一：

- 执行1次：  
    java proxy = 5ms  
    cglib proxy = 78ms
    
- 执行100次：
    
    java proxy = 7  
    cglib proxy = 71
    
- 执行10w次：
    
    java proxy = 41  
    cglib proxy = 110
    

可见，jdk的动态代理确实要更加快一点。

事实上，jdk和cglib都有缓存机制，也就是说如果要代理的内容完全一致，那么会先看缓存有没有，如果有直接走缓存，缓存没有才继续创建。所以实验结果随着创建数量的增加逐渐接近。

cglib提供了不使用缓存的机制。jdk似乎并没有提供关闭缓存的选项，因此不进行进一步测试。

最后，似乎算作是cglib的一个缺点，当跑10w次的时候，class下面创建了大量的字节码文件，也就是每生成一个代理类都会创建一个字节码文件。要小心因此造成的内存溢出。

​![[Pasted image 20250406184441.png]]​

3、测试代码二

![[Pasted image 20250406184458.png]]​
之所以有测试代码二，是因为某些场景下说jdk动态代理慢是因为它每次调用方法的时候都是基于反射更慢。所以，如果把测试重点放到方法调用上，jdk的动态代理真的会更慢吗？

```java
/**
 * @author zwt
 * @date 2024/6/13 - 21:21
 */
public class Test {
    private static final int cnt = 10000;

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        javaTest();
        long mid = System.currentTimeMillis();
        cglibTest();
        long end = System.currentTimeMillis();
        System.out.println("java proxy = " + (mid - start));
        System.out.println("cglib proxy = " + (end - mid));

    }

    public static void javaTest() {
        final User user  = new User();
        Say say = (Say)Proxy.newProxyInstance(User.class.getClassLoader(), new Class[]{Say.class}, new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("java proxy");
                return method.invoke(user, args);
            }
        });
        for (int i = 0; i < cnt; i++) {
            say.say();
        }
    }

    public static void cglibTest() {
        final User user = new User();
        // 设置enhancer对象的父类
        Enhancer enhancer = new Enhancer();
        enhancer.setUseCache(true);
        enhancer.setSuperclass(User.class);
        // 设置enhancer的回调对象
        enhancer.setCallback(new MethodInterceptor() {
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                // 代理逻辑
                System.out.println("cglib proxy");
                return methodProxy.invokeSuper(o, objects);
            }
        });
        // 创建代理对象
        User proxyUser = (User)enhancer.create();
        for (int i = 0; i < cnt; i++) {
            proxyUser.say();
        }
    }
}


```

4、结果二

- 执行一次：  
    java proxy = 4  
    cglib proxy = 78
    
- 执行100次：
    
    java proxy = 7  
    cglib proxy = 83
    
- 执行10w次：  
    java proxy = 217  
    cglib proxy = 291
    

事实证明，jdk的动态代理一点也慢，优化的足够牛了。

### CGLIB源码解析

```java
添加debug参数，让cglib生成的class文件保存到指定的位置，如：-Dcglib.debugLocation=C:\Users\zwt\Desktop\learning\target\classes
```

0、流程总结

- 使用者通过api去设置一些被代理对象的属性（被代理类、缓存、回调）以及具体的增强逻辑；
- 将以上参数封装成一个key，生成对应的代理类，并缓存。
- 针对代理类生成对应的代理对象，在代理对象生成的过程中初始化一些参数（例如静态的ThreadLocal里面的Callback）。
- 执行代理对象的增强方法。

1、代理对象的类结构：

- 代理类继承于被代理类User，基于“继承”是cglib与jdk的重要区别。
    
- 方法和属性具有“格式配套”的特点。例如，相似的属性都有Method和MethodProxy类型，方法也类似（同时自动生成了toString、equals方法）。
    
- 生成的代理say()方法逻辑非常清晰：
    
    - 拿到MethodInterceptor，也就是我们的增强逻辑。如果没有，就初始化进行赋值MethodInterceptor。
    - 执行增强逻辑，如果拿不到就直接执行被代理对象的原始方法。
    
    所以，如何拿到这个MethodInterceptor是重点关注的内容。它的初始赋值逻辑在：MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;那么CGLIBCALLBACK_在哪里被初始化呢？
    

```java
public class User$$EnhancerByCGLIB$$59c1fe5d extends User implements Factory {
    private boolean CGLIB$BOUND;
    public static Object CGLIB$FACTORY_DATA;
    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;
    private static final Callback[] CGLIB$STATIC_CALLBACKS;
    private MethodInterceptor CGLIB$CALLBACK_0;
    private static Object CGLIB$CALLBACK_FILTER;
    private static final Method CGLIB$say$0$Method;
    private static final MethodProxy CGLIB$say$0$Proxy;
    private static final Object[] CGLIB$emptyArgs;
    private static final Method CGLIB$equals$1$Method;
    private static final MethodProxy CGLIB$equals$1$Proxy;
    private static final Method CGLIB$toString$2$Method;
    private static final MethodProxy CGLIB$toString$2$Proxy;
    private static final Method CGLIB$hashCode$3$Method;
    private static final MethodProxy CGLIB$hashCode$3$Proxy;
    private static final Method CGLIB$clone$4$Method;
    private static final MethodProxy CGLIB$clone$4$Proxy;

    static void CGLIB$STATICHOOK1() {
        CGLIB$THREAD_CALLBACKS = new ThreadLocal();
        CGLIB$emptyArgs = new Object[0];
        Class var0 = Class.forName("User$$EnhancerByCGLIB$$59c1fe5d");
        Class var1;
        Method[] var10000 = ReflectUtils.findMethods(new String[]{"equals", "(Ljava/lang/Object;)Z", "toString", "()Ljava/lang/String;", "hashCode", "()I", "clone", "()Ljava/lang/Object;"}, (var1 = Class.forName("java.lang.Object")).getDeclaredMethods());
        CGLIB$equals$1$Method = var10000[0];
        CGLIB$equals$1$Proxy = MethodProxy.create(var1, var0, "(Ljava/lang/Object;)Z", "equals", "CGLIB$equals$1");
        CGLIB$toString$2$Method = var10000[1];
        CGLIB$toString$2$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/String;", "toString", "CGLIB$toString$2");
        CGLIB$hashCode$3$Method = var10000[2];
        CGLIB$hashCode$3$Proxy = MethodProxy.create(var1, var0, "()I", "hashCode", "CGLIB$hashCode$3");
        CGLIB$clone$4$Method = var10000[3];
        CGLIB$clone$4$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/Object;", "clone", "CGLIB$clone$4");
		// 意义：从User这个类里面，找到一个没有返回值的、名字叫做“say”的方法
        CGLIB$say$0$Method = ReflectUtils.findMethods(new String[]{"say", "()V"}, (var1 = Class.forName("User")).getDeclaredMethods())[0];
        CGLIB$say$0$Proxy = MethodProxy.create(var1, var0, "()V", "say", "CGLIB$say$0");
    }

    final void CGLIB$say$0() {
        super.say();
    }

    public final void say() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            var10000.intercept(this, CGLIB$say$0$Method, CGLIB$emptyArgs, CGLIB$say$0$Proxy);
        } else {
            super.say();
        }
    }
	···
}
```

2、MethodInterceptor被创建在create时期。

- create方法中最重要的方法在于createHelper。他将输入的参数封装到一个Key参数里面，里面主要是我们要代理的一些参数，例如接口、回调等。这个key将会作为最终生成代理类对应的“key”存放在map中。也就是说，cglib的动态代理是有缓存的，对于相同key的代理可以使用缓存来获取。
    
    > 默认开启缓存，如果需要关闭可以：
    > 
    > ​enhancer.setUseCache(false);​​
    

```java
   
 private Object createHelper() {
        this.preValidate();
		// 将用户输入的被代理对象的信息封装成一个EnhanceKey
        Object key = KEY_FACTORY.newInstance(this.superclass != null ? this.superclass.getName() : null, 
										ReflectUtils.getNames(this.interfaces), 
										this.filter == ALL_ZERO ? null : new WeakCacheKey(this.filter),
										this.callbackTypes,
										this.useFactory,
										this.interceptDuringConstruction, 
										this.serialVersionUID
									);
        this.currentKey = key;
		// 生成代理对象
        Object result = super.create(key);
        return result;
    }
```

- 再看create方法
    
    - 里面的this就是Enhance，obj就是代理类。return的内容就是通过代理类生成的代理对象
    
    ```java
    protected Object create(Object key) {
            ···
                this.key = key;
                Object obj = data.get(this, this.getUseCache());
                return obj instanceof Class ? this.firstInstance((Class)obj) : this.nextInstance(obj);
    		···
        }
    ```
    
    - 其中get方法如下，可以看到缓存开关在此。真正的类生成（具体的方法、构造器、继承关系等）在gen.generate方法里面，底层使用的是asm框架，不细说了。
    
    ```java
            public Object get(AbstractClassGenerator gen, boolean useCache) {
                if (!useCache) {
                    return gen.generate(this);
                } else {
                    Object cachedValue = this.generatedClasses.get(gen);
                    return gen.unwrapCachedValue(cachedValue);
                }
            }
    ```
    
    - 拿到的一般是一个Class对象，因此走的是firstInstance。这个里面主要内容就是通过反射工具以及传进来的Class对象来创建代理对象：
    
    ```java
        private Object createUsingReflection(Class type) {
            setThreadCallbacks(type, this.callbacks);
    
            Object var2;
            try {
                if (this.argumentTypes != null) {
                    var2 = ReflectUtils.newInstance(type, this.argumentTypes, this.arguments);
                    return var2;
                }
    
                var2 = ReflectUtils.newInstance(type);
            } finally {
                setThreadCallbacks(type, (Callback[])null);
            }
    
            return var2;
        }
    
    ```
    
    在这里的静态方法setThreadCallbacks()就是将回调方法设置到了静态变量CGLIB$SET_THREAD_CALLBACKS里面，而此处正是MethodInterceptor的来源：
    
    ```java
       private static void setThreadCallbacks(Class type, Callback[] callbacks) {
            setCallbacksHelper(type, callbacks, "CGLIB$SET_THREAD_CALLBACKS");
        }
    
        private static void setCallbacksHelper(Class type, Callback[] callbacks, String methodName) {
            ···
            Method setter = getCallbacksSetter(type, methodName);
    		//	通过反射设置
            setter.invoke((Object)null, callbacks);
    		···
        }
    ```
    

3、MethodProxy解析

invoke和invokeSuper有啥区别？原理是啥？

```java
        ···
		enhancer.setCallback(new MethodInterceptor() {
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                // 代理逻辑
                method.invoke(user, objects);
                method.invokeSuper(user, objects);
                return null;
            }
        });
		···

User对应的代理类对象生成了如下两个和say有关的方法（注意是代理对象）：
    final void CGLIB$say$0() {
        super.say();
    }

    public final void say() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            var10000.intercept(this, CGLIB$say$0$Method, CGLIB$emptyArgs, CGLIB$say$0$Proxy);
        } else {
            super.say();
        }
    }

```

- methodProxy.invoke(target，object)想要执行的是say方法，此处target指的是被代理对象。如果target换成了o（代理对象），那么就会执行出错。因为执行target的say方法就是我们的业务逻辑，而o的say方法实际上还是需要走到这个增强逻辑，那么他就会死循环（栈溢出）。  
    ​![[Pasted image 20250406184800.png]]​
- methodProxy.invokeSuper(target，object)想要执行的是CGLIB&say方法，此处如果还是target对象，那么被代理对象里面会有这个方法吗？不会有，因此就会直接报错。所以，method.invokeSuper的得是o（代理对象）的CGLIB&say方法。  
    ​![[Pasted image 20250406184808.png]]​

所以说，如果是想调用增强逻辑使用invoke方法，如果指向调用被代理对象的方法那么要选择invokeSuper。

以iinvoke的源码进一步解析MehtodProxy：

invoke的核心代码如下，一共两处关注点：

- init方法初始化了什么动？
- fci.f1.invoke在干嘛？

```java
	// 此处的obj可以是代理对象、也可以传入非代理对象。这里传入的是代理对象
    public Object invoke(Object obj, Object[] args) throws Throwable {
        try {
            this.init();
            FastClassInfo fci = this.fastClassInfo;
            return fci.f1.invoke(fci.i1, obj, args);
        }
		···
    }
```

先看init方法：

注意看f1和f2的注释

```java
    private void init() {
        if (this.fastClassInfo == null) {
            synchronized(this.initLock) {
                if (this.fastClassInfo == null) {
                    CreateInfo ci = this.createInfo;
                    FastClassInfo fci = new FastClassInfo();
					// f1是被代理类的fastClass
                    fci.f1 = helper(ci, ci.c1);
					// f2是代理对象的fastClass
                    fci.f2 = helper(ci, ci.c2);
                    fci.i1 = fci.f1.getIndex(this.sig1);
                    fci.i2 = fci.f2.getIndex(this.sig2);
                    this.fastClassInfo = fci;
                    this.createInfo = null;
                }
            }
        }

    }
```

debug到这个地方可以发现以下几点：

- f1和f2分别可以在classes下面看到对应的类文件。
- getIndex本身是一个抽象的方法，在上面生成的类文件中全部重写。拿对应的key取debug取数可以看到，所调用对象的方法签名的值（this.sig1.toString().hashCode()​​）已经写死在了对应的fastClass文件中。通过该key拿到了对应要执行方法的序号（下面会展示这一步）。

综上来讲，这一部分是通过所要调用的方法的拿到对应的方法的序号，供后面实际调用。

​![[Pasted image 20250406184819.png]]​

上面已经通过方法拿到了对应的index索引（5和22），再看f1、f2对应的invoke：

f1:

```java
// var1是前面得到的方法索引；
// var2是传入的对象可以是代理对象也可以是被代理对象。此处看起来很正常，将其转化为HelloSpring类型，请注意f2中是如何操作的。
// 入参数
public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
		// 在这一部分尝试进行强制转换
        HelloSpring var10000 = (HelloSpring)var2;
        int var10001 = var1;

        try {
            switch (var10001) {
				···
				// 前面拿到了原始对象的序号就是5，因此此处调用的就是原始对象的say方法。f
                case 5:
                    var10000.say();
                    return null;
				···
  
    }
```

f2:

```java
 public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
        HelloSpring..EnhancerByCGLIB..19152a48 var10000 = (HelloSpring..EnhancerByCGLIB..19152a48)var2;
        int var10001 = var1;

        try {
            switch (var10001) {
				···
                case 22:		
                    var10000.CGLIB$say$6();
                    return null;
              	···
    }
```

对比f1的方法，这里就有意思，你传入的对象在第一行可以被转化为HelloSpring..EnhancerByCGLIB..19152a48对象吗（这里IDEA反编译有一定的问题，但可以确定肯定不是HelloSpring类）？

如果你传入的是SpringHello，要求你转化为HelloSpring..EnhancerByCGLIB..19152a48自然就错了。所以抛出了一个类型转化错误：

​![[Pasted image 20250406184831.png]]​

所以MethodProxy方法调用大概有一下几个步骤：

- 1、初始化对象，主要是将要调用的方法签名记录下来。
    
    ```java
            proxy.sig1 = new Signature(name1, desc);
            proxy.sig2 = new Signature(name2, desc);
    ```
    
- 2、生成代理类与被代理类对应的FastClass类。上面是代理类的FastClas，下面是被代理类的FastClass  
    ​![[Pasted image 20250406184913.png]]​
    

- 3、以方法签名作Key，分别从上面的两个FastClass里面拿到真实调用方法的序号（getIndex）。再以序号作为Key，去调用的最终需要调用的方法。

给你一个方法，一个对象，如何让该对象调用该方法呢？通过反射。

但是通过FastClass这样的技巧，规避了反射的调用。FastClass类作为要调用方法签名和真正调用之间的桥梁。

上面这么说看起来比较绕，实际上很简单。逻辑大概如此：

```java
    if ("func1") {
        obj.func1();
    }
```

看起来特别的朴素，不朴素的地方实际上在如何生成这样一个类，让他拥有这样一段逻辑。

至于为什么同一个类里面要先拿序号，再通过序号去调用对应的方法，这样绕一圈，不能直接像上面的方式去调用吗？我还没想清楚。