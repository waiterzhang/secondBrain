### 总结

1、配置初始化。根据Profile的配置拿到对应的配置文件。

2、刷新

* 预刷新：设置各种标记、必要的参数验证。
* 刷新beanFactroy（清除已有的beanFactory），之后通过解析器（有多重解析器）把需要注册的beanDefinition加载到beanFactory中，产生新的beanFactory。

### 场景

通过xml配置的方式，通过IOC容器获得一个Bean，以此来观察容器的初始化。

 1、有一个类

```java
@Data
public class HelloSpring {
    private String name;
}
```

2、对应的xml配置文件

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">

    <!-- 配置一个 bean -->
    <bean id="helloSpring" class="com.zwt.bean.HelloSpring">
        <!-- 为属性赋值 -->
        <!-- 通过属性注入: 通过 setter 方法注入属性值 -->
        <property name="name" value="Tom"></property>
    </bean>
  
</beans>
```

3、启动类

```java
public class Test {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext cpa = new ClassPathXmlApplicationContext("beans.xml");
        HelloSpring helloSpring = (HelloSpring)cpa.getBean("helloSpring");
        System.out.println(helloSpring.getName());
    }
}

// 输出结果：Tom
```

### 源码跟踪

1、构造器方法，两个地方比较关键：

* ​`setConfigLocations(configLocations)`​：解析配置文件。
* refresh刷新。

​![image](image-20240914175844-g385ynt.png)​

2、看一下setconfitlocation方法：

* 主要用于确定配置文件的路径。我们有不同的运行环境prod、beta等，这个时候加载的配置文件和属性有所区别。所以需要`Environment`​来区分。知道就行，不细说。

​![image](image-20240914180517-89gr2v5.png)​

​![image](image-20240914180933-5d8prjn.png)​

3、`refresh`​是重点

```java
public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");

			// 刷新准备：1、设置标记；2、初始化占位符属性（空实现）；3、必需属性校验（如果有），如果必须属性空了抛异常。
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);
				beanPostProcess.end();

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
				contextRefresh.end();
			}
		}
	}
```

* ​`prepareRefresh`​

  ```java
  	protected void prepareRefresh() {
  		// Switch to active.
  		this.startupDate = System.currentTimeMillis();
  		this.closed.set(false);
  		this.active.set(true);
  		···
  		initPropertySources();
  		getEnvironment().validateRequiredProperties();

  		// 存储监听器
  		···
  	}
  ```

  该方法主要作三件事：

  * 设置标记；
  * 属性初始化（空实现）、必需属性校验（如果缺失则抛出异常）
  * 存储监听器

    ​`obtainFreshBeanFactory`​

    ```java
    	protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    		refreshBeanFactory();
    		return getBeanFactory();
    	}
    ```

    ```java
    	@Override
    	protected final void refreshBeanFactory() throws BeansException {
    		if (hasBeanFactory()) {
    			destroyBeans();
    			closeBeanFactory();
    		}
    		try {
    			// 默认加载其父类bean factory
    			DefaultListableBeanFactory beanFactory = createBeanFactory();
    			beanFactory.setSerializationId(getId());
    			// 自定义BeanFacotry属性：1、是否允许循环依赖 2、是否允许同名BeanDefinition覆盖。不允许都会抛异常。
    			customizeBeanFactory(beanFactory);
    			// 加载BeanDefinition到给定的bean factory
    			loadBeanDefinitions(beanFactory);
    			this.beanFactory = beanFactory;
    		}
    		catch (IOException ex) {
    			throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
    		}
    	}
    ```

    该方法主要作两件事情：

    * 清理之前bean fatory的内容；
    * 初始化容器下一个生命周期所需的bean factory。这一步很重要，这一步新建了bean的容器、解析bean，并将bean注册到beanFactory里面。  
      重点在：`loadBeanDefinitions`​，该抽象方法由`AbstractXmlApplicationContext`​做了仅有的实现：

      ```java
      	// 通过xmlBeanDefinitionReader
      	@Override
      	protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
      		// Create a new XmlBeanDefinitionReader for the given BeanFactory.
      		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

      		// Configure the bean definition reader with this context's
      		// resource loading environment.
      		beanDefinitionReader.setEnvironment(this.getEnvironment());
      		beanDefinitionReader.setResourceLoader(this);
      		// 设置解析器去具体的解析dtd、schema的配置文件
      		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

      		// Allow a subclass to provide custom initialization of the reader,
      		// then proceed with actually loading the bean definitions.
      		initBeanDefinitionReader(beanDefinitionReader);
      		loadBeanDefinitions(beanDefinitionReader);
      	}
      ```

      看其中的loadBeanDefinitions：

      ```java
      	protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
      		// 此处就是我们传入的配置文件
      		Resource[] configResources = getConfigResources();
      		if (configResources != null) {
      			reader.loadBeanDefinitions(configResources);
      		}
      		String[] configLocations = getConfigLocations();
      		if (configLocations != null) {
      			reader.loadBeanDefinitions(configLocations);
      		}
      	}
      ===========================================================================================
      点进reader.loadBeanDefinitions(configLocations)（这个configLocations既可以是Resource，也可以是Path）：
      	@Override
      	public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {
      		Assert.notNull(resources, "Resource array must not be null");
      		int count = 0;
      		for (Resource resource : resources) {
      			count += loadBeanDefinitions(resource);
      		}
      		return count;
      	}
      ===========================================================================================
      点进loadBeanDefinitions并一路向下（太多了，不一一列举了），在这个过程中将Resouce包装成了EncodeResouce，
      又将EncodeResouce转换成了Document。最后在documentReader中将具体的BeanDifinition注册进去：

      	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
      		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
      		int countBefore = getRegistry().getBeanDefinitionCount();
      		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
      		return getRegistry().getBeanDefinitionCount() - countBefore;
      	}
      ===========================================================================================
      一路向下，可以找到的具体的解析方法：parseBeanDefinitions
      在这个方法里面，进行循环解析所有的标签。

      	protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
      		if (delegate.isDefaultNamespace(root)) {
      			NodeList nl = root.getChildNodes();
      			for (int i = 0; i < nl.getLength(); i++) {
      				Node node = nl.item(i);
      				if (node instanceof Element) {
      					Element ele = (Element) node;
      					if (delegate.isDefaultNamespace(ele)) {
      						parseDefaultElement(ele, delegate);
      					}
      					else {
      						delegate.parseCustomElement(ele);
      					}
      				}
      			}
      		}
      		else {
      			delegate.parseCustomElement(root);
      		}
      	}

      parseDefaultElement开始具体的解析是哪个标签：

      private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
      		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
      			importBeanDefinitionResource(ele);
      		}
      		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
      			processAliasRegistration(ele);
      		}
      		// 在这里面解析了bean标签
      		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
      			processBeanDefinition(ele, delegate);
      		}
      		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
      			// recurse
      			doRegisterBeanDefinitions(ele);
      		}
      	}

      看一下processBeanDefinition

      	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
      		// bdHolder这里面已经拿到了实际的bdHolder
      		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
      		if (bdHolder != null) {
      			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
      			try {
      				// 在这里被注册到给定的beanFactory
      				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
      			}
      		···
      		}
      	}


      查看一下具体的Bean标签解析，可以看到里面已经在拿具体的标签kv对了，同时拿到了一个：AbstractBeanDefinition
      这个AbstractBeanDefinition放在了Holder里面。随后，被注册进了容器当中。

      public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
      		String id = ele.getAttribute(ID_ATTRIBUTE);// id = helloSpring
      		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
      		···
      		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
      		if (beanDefinition != null) {
      			···
      			}
      			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
      		}

      		return null;
      	}


      ```

‍
