### Why：为什么会出现循环依赖？
当两个Bean（BeanA 和 BeanB）互相依赖时，创建流程如下：
**BeanA 创建过程**
1. ​​标记创建状态​​  
   `creatingSet<BeanA> ` 表示该Bean正在创建中。

2. ​​实例化与缓存​​  
   - 实例化BeanA的普通对象。
   - 将普通对象存入三级缓存：  
     `singletonFactories.put("A", A的普通对象)`。

3. ​​填充BeanB依赖​​  
   为BeanA填充属性BeanB时，触发BeanB的创建流程：
   - ​​3-1 实例化BeanB​​  
     初始化BeanB的普通对象。
   - 3-2 填充BeanB的A属性​​ 
     - 从单例池中查找BeanA，发现正在创建中（`creatingSet`）。
     - 触发循环依赖处理：
       - 从三级缓存获取BeanA的Lambda表达式。
       - 执行Lambda生成A的代理对象（若需AOP）/普通对象。
       - 将代理对象存入二级缓存：`earlySingletonObjects`。
   - ​3-3 填充其他属性​
   - ​3-4 AOP处理​
     生成完整代理对象（基于已填充的BeanB）。
   - ​3-5 加入单例池​
     完成BeanB后存入单例池。

4. ​填充BeanA其他属性​
   BeanA此时持有已初始化的BeanB。

5. ​AOP处理​
   - 从二级缓存（`earlySingletonObjects`）获取BeanA的早期代理对象。
   - 若未完成AOP，生成最终代理对象。

6. ​**​加入单例池​**​  
   将完整的BeanA存入一级缓存：`singletonObjects`。

---

## Q&A

**Q1：为什么需要三级缓存（ZwtMap）？**
​**​A1​**​  
直接保存普通对象时，若后续生成代理对象会导致缓存不一致（Map中仍为普通对象，实际应使用代理对象）。使用三级缓存（Lambda）延迟处理，在需要时才生成代理对象。

---

**Q2：能否在实例化时直接生成代理对象并缓存？**
​**​A2​**​  
可以（即提前AOP），但代理对象依赖的原始对象（target）尚未完成属性填充。若此时存入单例池，其他线程可能获取到不完整的对象。

---

**Q3：能否将AOP生成的代理对象直接加入单例池？**
​**​A3​**​  
不可行。代理对象的`target`仍指向未初始化的普通对象，此时代理对象不完整。单例池仅应存放完全初始化且可用的Bean。

---

**Q4：多线程下多个代理对象如何保证单例？**
​**​A4​**​  
二级缓存（`earlySingletonObjects`）保存提前生成的代理对象，确保后续依赖中其他Bean获取到同一实例，避免多例问题。

---

**Q5：代理对象与普通对象的生命周期关系？**
​**​A5​**​  
- ​**​普通对象​**​：完成属性填充后，进行AOP生成最终代理对象。  
- ​**​代理对象​**​：依赖普通对象的初始化，但生成后会覆盖原始对象。二级缓存代理对象解决线程安全问题，最终单例池中仅保留完整的代理对象。

---

**Q6：三级缓存的作用分别是什么？**
​**​A6​**​  
| 缓存层级 | 名称                                      | 作用                                                                
|----------|---------------------------|---------------------------------------------------------
| 一级缓存 | `singletonObjects`           | 存储完全初始化的单例Bean，可直接被使用。                     
| 二级缓存 | `earlySingletonObjects`  | 存储因循环依赖提前生成的代理对象，确保代理对象的单例性。               
| 三级缓存 | `singletonFactories`        | 存储普通对象的Lambda表达式，用于在循环依赖时延时生成代理对象或普通对象。 


![[Pasted image 20250406185729.png]]