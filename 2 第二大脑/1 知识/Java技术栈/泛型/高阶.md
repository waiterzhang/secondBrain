# 高阶

> Java的泛型是假的泛型、有缺陷的泛型，因此产生了一些奇怪的特性。
>
> 泛型通配符是解决泛型容器之间没有继承关系的一种手段，但这个手段看起来非常的像一个怪胎。

## 泛型无继承关系带来的问题

正如前面所说，泛型之间没有“继承”这种关系的传递。所以产生了一些问题：

有两个类：苹果和水果

```java
class Fruit {}
class Apple extends Fruit {}
```

有一个简单的容器类Plate。盘子里面可以支持存set、取get服务。

```java
public class Plate <T>{
    private T item;
    public Plate(T t) {
        item = t;
    }

    public T getItem() {
        return item;
    }

    public void setItem(T item) {
        this.item = item;
    }
}
```

现在定义一个装水果的盘子，理论上来讲他肯定是一个可以装苹果的盘子。但是编译器会报错：

​​![image](image-20240105150430-y5qt2cj.png)​​

指定了泛型的荣期间，没有继承关系。这在java里面非常的违反直觉。

为了让这种泛型容器之间使用起来更顺畅，使用\<? extends T\>和\<?super T\>来让水果盘子和苹果盘子之间发生关联。

## 通配符

\<? extends T\>为上界通配符，指的是T的及其所有子孙均可；

\<? super T\>为下界通配符，指的是T及所有祖先均可。

改成这个样子就可以了：

```java
    public static void main(String[] args) {
        Plate<? extends Fruit> p = new Plate<Apple>(new Apple());
    }
```

**这样也会带来一些副作用：**

这种限制，使得容器的部分功能可能失效。

\<? extends T\>上界通配符使得set方法失效，但是get方法仍能正常。

\<? super T\>下界通配符会使get功能部分失效，get到的内容只能存放到Object对象中，set方法正常。

​![image](image-20240105151534-b22y95p.png)​

**为什么会失效？**

我想有两个原因：

* java的泛型是假的泛型，会在编译期间擦除泛型，使用真正的类型来代替。
* 而java本身是一个静态语言，已经声明装APPLE的盘子，就不能再装Banner了；

下面分析一下具体的例子：

* 对于上界通配符，先说Set方法为什么不行？get为什么行？  
  Plast\<? extend Fruit\>这个泛型盘子，一定会在编译期间确定其类型，编译器看到你在构造器中放了一个Apple进去，则编译期间泛型就会被具体的类型Apple替代，下面又set了一个Banner进去，那Banner能转型成Apple吗？显然不行，这就会产生错误，所以干脆禁止你set进去。  
  既然禁止你set了，那么类型显然就是构造时的类型。所以get的类型是确定的。

* 对于下界通配符sGet为什么会部分失效？

  Get为什么部分失效？谁也不知道盘子放进去的都是些什么，放进去一个Apple，放进去一个Fruit，它们都可以转型为Object，安全转型的同时，类的信息也丢掉了一部分。

究其原因，java是一门静态语言。

‍
