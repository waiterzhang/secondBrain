## 1.Java泛型的实现方法

> Java的泛型会在编译前进行擦除，替换为原始类型；

Java的泛型是伪泛型，在Java在编译期间，所有的泛型信息都会被擦掉。正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程称为类型擦除。

例如，在代码中定义List<String>和List<Objectd>类型，在编译之后只有List，Jvm看不到附加的泛型信息。
<red>

```java
    public static void main(String[] args) {

        ArrayList<String> list1 = new ArrayList<String>();
        list1.add("abc");

        ArrayList<Integer> list2 = new ArrayList<Integer>();
        list2.add(123);

        System.out.println(list1.getClass() == list2.getClass());
    }
```

从上面的程序可以看出，运行期间两个List类型一致。

## 2.类型擦除后保留的原始类型

> 泛型类自写出来就确定了其原始类型；
>
> 泛型方法需要寻找其“最大公约数”；

原始类型就是擦除了泛型信息，最后在字节码中的类型变量的真正类型。

例如的泛型类：

```java
class Pair<T> {  
    private T value;  
    public T getValue() {  
        return value;  
    }  
    public void setValue(T  value) {  
        this.value = value;  
    }  
} 
```

Pari的原始类型：

```java
class Pair {  
    private Object value;  
    public Object getValue() {  
        return value;  
    }  
    public void setValue(Object  value) {  
        this.value = value;  
    }  
}
```

**泛型类**确定原始类型的规则

* 无限定类型变量，使用Object替换
* 有限定，则使用第一个边界的类型变量替换；

  ```java
  public class Pair<T extends Comparable> {} // 原始类型为Comparable
  ```

**泛型方法**确定原始类型的规则

* 不指定泛型时，泛型变量为该方法的几种类型的最近的同一父类；
* 在指定泛型时，泛型变量必须为该泛型或其字类；

> **注意：**
>
> 泛型**类**自造出来就确定了其原始类型。例如ArrayList，无论使用的时候使用的时什么泛型指定，最后的原始类型都替换成Object。

## 3.类型擦除引起的问题及解决方法

> 编译期间的泛型检查是绑定在引用上的；

**如何理解绑定在引用上？**

泛型在编译之前进行检查。IDE报错说明是在编译之前进行检查：

```java
public static  void main(String[] args) {  

    ArrayList<String> list = new ArrayList<String>();  
    list.add("123");  
    list.add(123);//编译错误  
}
```

如果是编译之后进行检查，那么类型擦除之后ArrayList可以存储Object，那么就不会报错了。

**类型检查是针对谁的呢？针对引用。**

```java
ArrayList<String> list1 = new ArrayList(); //情况1
ArrayList list2 = new ArrayList<String>(); //情况2
```

* 情况1是常见的写法，这种方法有用，可以对加入list1的元素进行类型检查。
* 情况2完全起不到类型检查的作用，new ArrayList仅仅是开辟内存空间。

因为泛型的类型检查针对的是引用，看下面这个例子：

```java
    public static void main(String[] args) {

        ArrayList<String> list1 = new ArrayList<String>();
        list1.add("abc");
        add(list1);
        System.out.println(list1);
		//[abc, 1]

    }
    public static void add(List m) {
        m.add(1);
    }
```

list1是有泛型检查的，但是m是没有泛型检查的，因此最后list1所指向的空间里面可以存储整形、字符串，即使开辟空间的时候使用了ArrayList<String>来指定它的引用。

因为泛型针对的是引用，只有在这个引用调用的时候才会进行泛型检查。

**自动类型转换**​

前面说了，编译时会擦出泛型，转化为原始类型，但是使用的时候为什么没有进行强制类型转换呢？

因此java已经帮忙做过了，看下面ArrayList的代码：

```java
    public E get(int index) {
        rangeCheck(index);

        return elementData(index);
    }

    E elementData(int index) {
        return (E) elementData[index];
    }

```

​

‍

‍
