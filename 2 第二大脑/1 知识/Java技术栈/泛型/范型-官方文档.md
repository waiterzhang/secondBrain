
> 非新手教程，节选一些具有一定理解难度、或者揭示背后原理/设计思路的章节进行学习。

## 范型与子类型

检查一下你对范型的理解，以下的代码是否合法？

```java
List<String> ls = new ArrayList<String>(); // 1
List<Object> lo = ls; // 2 
```

第一行肯定没有问题。

第二行对吗？好像也没问题，因为Object是String的父类。

再来看一下下面的操作：

```java
lo.add(new Object()); // 3
String s = ls.get(0); // 4
```

第四行，将一个Object类型的元素指派给String类型。这肯定会有严重的问题，Object哪能去做具有String特性的动作呢？

实际上，编译器会直接报错。

**通常，如果Foo是Bar的子类型（或者接口），G是范型类型声明。则G&lt;Foo&gt;不是G&lt;Bar&gt;的子范型**。这有一些反直觉。原因在于我们应该假设集合会不断变化。

> 举一个例子：  
> 假设机动车部门向人口普查局提供司机名单，我们认为`List<Driver>`​是`List<Person>`​的子类型，这看起来很合理。实际上在传递的时候，传递的是司机名单的副本，否则人口普查局可能会将非司机的人口添加到名单中，这就破坏了机动车部门的名单。

## 通配符

考虑一个例子：打印集合中的所有元素，在5.0之前这样写：

```java
void printCollection(Collection c) {
    Iterator i = c.iterator();
    for (k = 0; k < c.size(); k++) {
        System.out.println(i.next());
    }
}
```

使用范型的新写法：

```java
void printCollection(Collection<Object> c) {
    for (Object e : c) {
        System.out.println(e);
    }
}
```

新方法比旧方法更好。虽然旧方法可以被任何类型的集合调用，但新方法只接受Collection<Object>。

> 好在哪？

注意Collection<Object>不是任何集合类型的父类。那么各个集合的父类型是什么呢？它被写成`Collection<?>`​，也被称为通配符类型。上面的例子可以这样写：

```java
void printCollection(Collection<?> c) {
    for (Object e : c) {
        System.out.println(e);
    }
}
```

现在，我们可以使用任何类型的集合调用他。请注意：printCollection中，我们仍然可以从中读取元素并赋予他们Object类型，因为Object类型是所有类的父类。**但是，往集合里面添加元素并不安全**

```java
Collection<?> c = new ArrayList<String>();
c.add(new Object()); // Compile time error
```

原因在于，我们并不知道c里面的？具体代表什么类型。唯一例外的是可以添加null，因为null可以是每种类型的成员。

另一方面，对于List<?>我们可以调用get方法使用其结果。结果是未知类型，但是它肯定是一个Object对象。因此将get方法的结果分配给一个Object变量是安全的。

### 有界通配符

考虑一个简单的绘图程序，他可以绘制圆形、举行。若要在程序中表示这些形状，可以定义如下类层次结构：

```java
public abstract class Shape {
    public abstract void draw(Canvas c);
}

public class Circle extends Shape {
    private int x, y, radius;
    public void draw(Canvas c) {
        ...
    }
}

public class Rectangle extends Shape {
    private int x, y, width, height;
    public void draw(Canvas c) {
        ...
    }
}
```

绘制图形：

```java
public class Canvas {
    public void draw(Shape s) {
        s.draw(this);
   }
}
```

任何图形通常都包含很多形状，假设他们是一个列表。那么有一个方法可以让Canvas将他们全部绘制出来：

```java
public void drawAll(List<Shape> shapes) {
    for (Shape s: shapes) {
        s.draw(this);
   }
}
```

看起来很美好，但是别忘了，上面的前置知识告诉我们这样并不可取。因为List<Circle>并非是List<Shape>的子类，所以List<Circle>无法被使用。我们真正想要的是可以让改方法接受任何形状的列表：

```java
public void drawAll(List<? extends Shape> shapes) {
    ...
}
```

这里有一个很小的区别。我们将List<Shape>替换为List<? extend Shape>，现在drawAll就可以接受任何子类的Shape列表。

List<? extend Shape>是有界通配符的一个示例。 **？代表未知类型，但是在我们声明界限的情况下，编译器知道这种未知类型必须是Shape或其子类型。**

像往常一样，使用通配符的灵活性是需要代价的。这个代价是在方法体中写入shapes是非法的。例如：

```java
public void addRectangle(List<? extends Shape> shapes) {
    // Compile-time error!
    shapes.add(0, new Rectangle());
}
```

我们应该弄清楚为什么上面的代码是不对的。

shapes.add第二个参数是<? extends Shape>，表示是Shape的未知子类型，但是不知道具体是什么类型。它可以是Rectangle也可以不是Rectangle，因此在这里传递Rectangle是不安全的。

> 为什么不安全？不太懂。
>
> todo：再次深入学习一下

## 范型方法

请尝试写一个方法，该方法将数组对象，转换为一个集合对象：

```java
static void fromArrayToCollection(Object[] a, Collection<?> c) {
    for (Object o : a) { 
        c.add(o); // compile-time error
    }
}
```

首先，没有使用`Collection<Object>`​作为型参。说明学到了一点东西，如果使用`Collection<Object>`​，则只能传递`Collection<Object>`​类型的参数，无法传递其任何“子类”。

其次，学习了前面的前置知识，知道上面这种写法也是要编译出错的。原因在于？到底是什么类型呢？（编译器不知道，所以在范型擦出的时候，他咋知道要替换为什么具体类型呢？）。

处理这个问题应该采用范型方法。就像声明类型一样，方法声明也可以类型参数范型化。

```java
static <T> void fromArrayToCollection(T[] a, Collection<T> c) {
    for (T o : a) {
        c.add(o); // Correct
    }
}
```

我们可以用任何类型的集合调用此方法，其元素类型是数组元素类型的**或其超类**

```java
Object[] oa = new Object[100];
Collection<Object> co = new ArrayList<Object>();

// T 被推断为 Object
fromArrayToCollection(oa, co); 

String[] sa = new String[100];
Collection<String> cs = new ArrayList<String>();

// T 被推断为 String
fromArrayToCollection(sa, cs);

// T 被推断为 Object
fromArrayToCollection(sa, co);
```

范型参数T被编译器动态的推断为两个参数的最近父类，以保证入参的正确。

### 使用

有一个问题：什么时候使用范型方法，什么时候使用通配符类型？。未了便于理解，看一下Collection库中的几个方法。

```javascript
interface Collection<E> {
    public boolean containsAll(Collection<?> c);
	boolean add(E e);
    public boolean addAll(Collection<? extends E> c);
	default boolean removeIf(Predicate<? super E> filter)；
}
```

1、无界通配符？和Object元素的区别是什么？例子如下：

```javascript
public boolean containsAll(Collection c);
public boolean containsAll(Collection<?> c);
```

这两个不都能表示是任意元素吗？

两者在用途上可以说是一样的，都可以去填充任意类型的元素。并不会导致编译报错。

?只能出现在方法入参和引用中，起到**告知**的作用，并不能进行传递，也不需要传递。

```javascript
Class<?> c = xxxx;//ok
public void print(List<?> l){};//ok
public class Test<?>//No
```

在这里无界通配符只是起到告知及修饰的作用，可以直观的告诉使用者，可以接受任意类型。

* List可以理解为持有任意Object类型的原始列表；
* List<?>可以理解为想要使用泛型列表，但是不确定具体的类型。

两者有一些共同点，从方法入参的角度来讲他俩作用是一致的：

```javascript
public class MyCollection{
    public void test1(List<?> list) {

    }
    public void test2(List list) {

    }
}
```

也有一些区别：

```javascript
    public static void main(String[] args) {
        List<?> l1 = new ArrayList<>();
        List l2 = new ArrayList<>();
        l1.add("123");// 编译出错
        l1.add(null);// 编译正确
        l2.add("123");// 编译正确
    }
```

由于l1无法在编译期间确定他的具体类型是什么，所以l1禁止往里面添加元素。有一个例外就是null，null可以被视作任意类型的元素。

因此，<?>常见于方法的入参，而很少用于引用的定义。

2、什么时候使用泛型方法？以及明确的泛型？

在需要建立类型联系的时候需要使用明确的泛型参数。例如：

```javascript
public interface Collection<E> extends Iterable<E> {
    boolean add(E e);
}
```

这段代码，泛型所限制的意义为。E类型的参数必须，该类型参数必须实现Iterable接口。同时调用add方法的时候，该类型应该和声明在Collection中的参数类型、实现Iterable接口的参数类型一致。可见，三处元素类型要求一致。这种一致性，就是由明确声明的类型E来约束。

3、什么时候使用上界/下界通配符？

这一点奇怪的限制，还是来源于编译器**需要推断出合法**的类型。

假设有这样的继承关系：

Apple extends Fruit extends Food

* List<? extend Fruit> list：

  * 能不能读？假设list泛型实际指向Apple，可以读，使用Furit作为get的结果即可。因为Apple必定包含Furit的所有属性。这样转型是安全的。
  * 能不能写？假设list泛型实际指向Apple，此时我需要写一个Banner进去。没有一个具体的类型可以既是Apple又是Banner，这样就会类型冲突了。
* List<? super Apple> list:

  * 能不能读？假设list泛型实际指向了Furit，Fruit能否被安全的转型到Apple给到调用者？显然不行。Furit缺少Apple中特有的属性。
  * 能不能写？假设list泛型实际指向了Furit，添加进去Apple能否被转型到Fruit，显然不行。

首先要理解List<? super T> list、List<? super T> list这个引用代表什么？

代表list可以指向其限定范围的具体泛型容器，具体指向什么不能确定。在不能确定的情况下，将非确定类型转换到指定的类型T会不会出问题？

获取一个元素，调用方法，为了保证调用方法不出问题，T作为父类可以作为所有子类方法的公约数。

写入一个元素，为了保证转型没有问题，所以使用子类当下限，因为所有子类都可以安全转向其父类。

**总结：**

调用方法，共同父类可以保证方法都存在，所以如果需要读取则需要其类型的上限。

写入方法，要保证转型不出问题，所以需要子类下限。

有限范围内，一个父类可以在读取的时候代表所有的具体子类。

有限范围内，一个子类可以向上转型为其所有父类。

如果还不明白，可以看一下这个方法：

```javascript
public static <T> void copy(List<? super T> dest, List<? extends T> src)；

```

‍
