# 第五章 终结操作

## 避免使用reduce方法

reduce方法可以减少流，但是手动进行reduce的实现比较麻烦，需要注意的点很多。

它只是在没有解决办法的时候，才应该作为最后的手段来被考虑。

## 计算流处理的元素数量

所有的流中都有count这个接口，它的返回值是一个long类型，他之所以是一个long类型，而非一个int类型，是因为这个数量很有可能超过Intger.Max这个数字，因为你可能操作多个源的内容，也可能通过某个中间操作创建出更多待处理的元素，例如flatmap。

## 逐一消费每一个元素

foreach方法允许将流中的每一个元素传递给Consumer，此方法对于打印非常有用。

但是Consumer不要取影响外部的变量，例如：

```java
Stream<String> strings = Stream.of("one", "two", "three", "four");
List<String> result = new ArrayList<>();

strings.filter(s -> s.length() == 3)
       .map(String::toUpperCase)
       .forEach(result::add);

System.out.println("result = " + result);
```

在流的内部去操作外部列表result的值。

这样做会使您的 lambda 表达式变为captching * * lambda 表达式，这样严重影响性能，其次也无法使流并行。可以考虑这样做：

```java
Stream<String> strings = Stream.of("one", "two", "three", "four");

List<String> result = 
    strings.filter(s -> s.length() == 3)
           .map(String::toUpperCase)
           .collect(Collectors.toList());
```

这样收集器会创建一个ArrayList实例，并将处理的元素添加到其中。并行性由Collectors来处理，并不需要使用者操心。

## 将元素放到集合或数组中

收集到**arrayList**

```java
Stream<String> strings = Stream.of("one", "two", "three", "four");

List<String> result = 
    strings.filter(s -> s.length() == 3)
           .map(String::toUpperCase)
           .collect(Collectors.toList());
```

ArrayList有扩容的动作，扩容会在一定程度上影响性能，如果提前知道流处理元素的大小，可以使用固定容量的ArrayList

```java
Stream<String> strings = ...;

List<String> result = 
    strings.filter(s -> s.length() == 3)
           .map(String::toUpperCase)
           .collect(Collectors.toCollection(() -> new ArrayList<>(10_000)));
```

**收集到不可变列表**

```java
Stream<String> strings = ...;

List<String> result = 
    strings.filter(s -> s.length() == 3)
           .map(String::toUpperCase)
           .collect(Collectors.toUnmodifiableList()));
```

**收集在指定集合中**

```java
Stream<String> strings = ...;

List<String> result = 
    strings.filter(s -> s.length() == 3)
           .map(String::toUpperCase)
           .collect(Collectors.toCollection(LinkedList::new));
```

**收集到数组中**

```java
Stream<String> strings = ...;

String[] result = 
    strings.filter(s -> s.length() == 3)
           .map(String::toUpperCase)
           .toArray(String[]::new);

System.out.println("result = " + Arrays.toString(result));
```

**查找操作**​

Stream API提供了两个方法来查找元素

* findFirst
* findAny

这两个方法不接受任何参数，会返回流中的Identify元素。

如果数据源是有序的，那么流就是有序的（例如List接口天然有序），如果流没有排序，或者顺序在处理的过程中消失了，那么他可能返回任意一个元素。

调用findFirst会触发流中的一些检查，以确保获取该流的第一个元素。如果流是并行的流，那么代价比较高昂。在许多情况下，如果找到个第一个元素不是很重要，只是想获得任意一个元素，可以使用findAny而不是findFirst。

**匹配操作**​

有的时候需要知道流中是否存在某些元素，具体的元素无所谓，重点是这个元素在不在。也可以使用上面的API：

```java
boolean exists =
    strings.stream()
           .filter(s -> s.length() == 3)
           .findFirst()
           .isPresent();
```

但是还有更加高效的办法：

* ​[`anyMatch(predicate)`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html#anyMatch(java.util.function.Predicate))​：`true`​如果找到流中与给定谓词匹配的一个元素，则返回。
* ​[`allMatch(predicate)`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html#allMatch(java.util.function.Predicate))​`true`​：如果流的所有元素都与谓词匹配，则返回。
* ​[`noneMatch(predicate)`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html#noneMatch(java.util.function.Predicate))​：`true`​如果没有元素与谓词匹配，则返回。

```java
Collection<String> strings =
    List.of("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten");

boolean noBlank  = 
        strings.stream()
               .allMatch(Predicate.not(String::isBlank));
boolean oneGT3   = 
        strings.stream()
               .anyMatch(s -> s.length() == 3);
boolean allLT10  = 
        strings.stream()
               .noneMatch(s -> s.length() > 10);
    
System.out.println("noBlank = " + noBlank);
System.out.println("oneGT3  = " + oneGT3);
System.out.println("allLT10 = " + allLT10);

noBlank = true
oneGT3  = true
allLT10 = true
```

‍
