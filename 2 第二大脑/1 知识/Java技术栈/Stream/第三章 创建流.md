# 第三章 创建流

## 集合与迭代器创建流

* Collection接口里面有stream（）方法，因此任何集合都可以直接获得一个stream。map并非collection，但是他又keys、values、entryset等都属于集合。

## 创建一个空流

```java
Stream<String> empty = Stream.empty();
List<String> strings = empty.collect(Collectors.toList());

System.out.println("strings = " + strings);
```

## 从数组创建

直接创建

```java
Stream<Integer> intStream = Stream.of(1, 2, 3);
List<Integer> ints = intStream.collect(Collectors.toList());

System.out.println("ints = " + ints);
```

通过Arrays.stream

```java
String[] stringArray = {"one", "two", "three"};
Stream<String> stringStream = Arrays.stream(stringArray);
List<String> strings = stringStream.collect(Collectors.toList());

System.out.println("strings = " + strings);
```

## 通过Supplier创建

Stream提供了工厂方法generate()，当每次需要的时候都会调用该工厂方法。下面这种方法永远不会停止：

```java
Stream<String> generated = Stream.generate(() -> "+");
List<String> strings = generated.collect(Collectors.toList());
```

为了使流在某个时刻停止，可以使用limit：

```java
Stream<String> generated = Stream.generate(() -> "+");
List<String> strings = 
        generated
           .limit(10L)
           .collect(Collectors.toList());

System.out.println("strings = " + strings);
```

## 通过种子流

如果需要不断迭代的内容，可以考虑[`iterate()`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/Stream.html#iterate(T,java.util.function.UnaryOperator))​，他将会通过转换输入参数生成流的下一个元素。

```java
Stream<String> iterated = Stream.iterate("+", s -> s + "+");
iterated.limit(5L).forEach(System.out::println);
```

**还有更多，不一一列举了，感觉用不上。**

‍
