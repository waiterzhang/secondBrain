# 第四章 减少流

除了调用终结操作以外，还可以使用reduce来减少流。

## 使用二元运算符

所谓的二元运算符就是类似于加减乘除这种操作，有两个元素形成第三个原因，即2个入参，1个返回值。显然，这样可以减少流。

如果相对一个整数列表求和：

```java
List<Integer> ints = List.of(3, 6, 2, 1);

int sum = ints.get(0);
for (int index = 1; index < ints.size(); index++) {
    sum += ints.get(index);
}
System.out.println("sum = " + sum);
```

可以理解为这样:​![image](image-20231118201925-ue5l4ay.png)​

那么这种方式也可以使用二元运算符实现：

```java
List<Integer> ints = List.of(3, 6, 2, 1);
BinaryOperator<Integer> sum = (a, b) -> a + b;

int result = ints.get(0);
for (int index = 1; index < ints.size(); index++) {
    result = sum.apply(result, ints.get(index));
}
System.out.println("sum = " + result);
```

可以发现，这个操作只依赖于二元运算符本身。如果想要获得最大值可以这样（只需要换二元运算符即可）：

```java
List<Integer> ints = List.of(3, 6, 2, 1);
BinaryOperator<Integer> max = (a, b) -> a > b ? a: b;

int result = ints.get(0);
for (int index = 1; index < ints.size(); index++) {
    result = max.apply(result, ints.get(index));
}
System.out.println("max = " + result);
```

> 这个地方和传入比较器获得最大值、最小值是一样的。比较器就可以看作一个二元运算符，输入两个数，输出一个代表大小的数值。

因此，可以通过实现这个二元运算符来实现对流的合并操作。

## 并行使用二元运算符

官网的内容太多了，简而言之例子可以理解为归并排序。

归并排序中有个默认的二元运算就是比大小。

归并排序显然可以并行运算，分组求出组内最值，然后比较组件最值。

但是里面也有一个问题，就是分治计算的顺序，不能影响最终结果。
